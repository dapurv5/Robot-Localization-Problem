\documentclass[a4paper,10pt]{article}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{color}
\usepackage{subfigure}
\usepackage{graphicx}


%opening
\title{Robot Localization Simulator}
\author{}


\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{example}[theorem]{Example}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}



\begin{document}

\maketitle

\begin{abstract}
In this project we explore the various algorithms for the Robot Localization Problem and build a simulator to visualize the results on
various 2D maps.
Robot localization is an important problem in robotics. Simply put, the robot localization problem is as follows. A robot is 
placed at an unknown point inside a simple polygon $ P $. The robot has a map of 
$ P$ and can compute visibility polygon from its current location. The robot must determine its correct 
location inside the polygon $P $ at a minimum cost of travel distance. We implement an ${O(\log^3 n)} $ factor approximation algorithm 
as given by \cite{key1}. CGAL \cite{key2} has been used for the various computational geometry algorithms.

\end{abstract}

\newpage

\section{Computing Visibility Polygons}
Visibility polygon is an indispensable component is the hypothesis generation step of the algorithm. Since CGAL had no inbuilt support
 for computing visibility polygons we implemented the following two routines for our purposes.
\begin{itemize}
 \item Visibility Polygon of a point inside a polygon
 \item Visibility Polygon of an edge of the polygon.
\end{itemize}

\subsection{Visibility Polygon of a Point Inside a Polygon}

The following is the C++ function in the file PolygonUtil.cpp. We pass the map polygon and the point $P$, whose visibility polygon is to be
 computed. The function returns the visibility polygon of $P$ as another Polygon type.
In $setVisiblePoints$ we collect all those points which are directly visible from $P$. Note that
 all these points will form a part of the visibility polygon of $P$ since they are directly visible from $P$. 
Besides these some additional spurious vertices will also be introduced. Each spurious vertex which is a part of the visibility polygon
 can be obtained by extending the line joining the point $P$ to some reflex vertex. We do this in the if block and collect all the 
spurious vertices also. Finally we sort all the vertices obtained in an order so that they form the visibility polygon of $P$.





%Java2TeX style definitions
%You can modify them to fit your needs
\newcommand{\jttstylea}{\color[rgb]{1.00,1.00,1.00}} %Background
\newcommand{\jttstyleb}{\color[rgb]{.501,.501,.501}} %Line numbers
\newcommand{\jttstylec}{\color[rgb]{.247,.498,.372}} %Multi-line comments
\newcommand{\jttstyled}{\color[rgb]{.247,.498,.372}} %Single-line comments
\newcommand{\jttstylee}{\color[rgb]{.498,.000,.333}} %Keywords
\newcommand{\jttstylef}{\color[rgb]{.164,.000,1.00}} %Strings
\newcommand{\jttstyleg}{\color[rgb]{.600,.000,.000}} %Character constants
\newcommand{\jttstyleh}{\color[rgb]{.600,.000,.000}} %Numeric constants
\newcommand{\jttstylei}{\color[rgb]{.000,.000,.000}} %Parenthesis
\newcommand{\jttstylej}{\color[rgb]{.498,.000,.333}} %Primitive Types
\newcommand{\jttstylek}{\color[rgb]{.000,.000,.000}} %Others
\newcommand{\jttstylel}{\color[rgb]{.498,.623,.749}} %Javadoc keywords
\newcommand{\jttstylem}{\color[rgb]{.498,.498,.623}} %Javadoc HTML tags
\newcommand{\jttstylen}{\color[rgb]{.247,.247,.749}} %Javadoc links
\newcommand{\jttstyleo}{\color[rgb]{.247,.372,.749}} %Javadoc others
\newcommand{\jttstylep}{\color[rgb]{1.00,.380,.000}} %Undefined
\newcommand{\jttstyleq}{\color[rgb]{.392,.392,.392}} %Annotation

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  Java Sourcecode to TeX automatically converted code
%  Java2Html Converter 5.0 [2006-02-26]by Markus Gebhard  markus@jave.de
%     Further information: http://www.java2html.de
{
\noindent \ttfamily
\jttstylea \\
\jttstylea \\
\jttstylea \\
\jttstylek Polygon~PolygonUtil::CalcVisibilityPolygon\jttstylei (\jttstylek Polygon\&~map,~Point\&~point\jttstylei )\\
\jttstylei \{\\
\jttstylea ~~\jttstylek using~namespace~std;\\
\jttstylea ~~\jttstylek Polygon~setVisiblePoints~=~VisiblePointSet\jttstylei (\jttstylek map,point\jttstylei )\jttstylek ;\\
\jttstylea \\
\jttstylea ~~\jttstylek list\verb#<#Point\verb#>#~listVisiblePoints;\\
\jttstylea ~~\jttstylek fixedPoint=point;\\
\jttstylea \\
\jttstylea ~~\jttstylee for~\jttstylei (\jttstylek VertexIterator~vi~=~setVisiblePoints.vertices\verb#_#begin\jttstylei ()\jttstylek ;\\
\jttstylea ~~~~~~~~~~~~\jttstylek vi~!=~setVisiblePoints.vertices\verb#_#end\jttstylei ()\jttstylek ;~++vi\jttstylei )\\
\jttstylea ~~\jttstylei \{\\
\jttstylea ~~~~\jttstylek listVisiblePoints.push\verb#_#back\jttstylei (\jttstylek \verb#*#vi\jttstylei )\jttstylek ;\\
\jttstylea ~~~~\jttstylee if\jttstylei (\jttstylek IsReflex\jttstylei (\jttstylek map,\verb#*#vi\jttstylei ))\\
\jttstylea ~~~~\jttstylei \{\\
\jttstylea ~~~~~~\jttstylek Ray~rayToCorner\jttstylei (\jttstylek point,\verb#*#vi\jttstylei )\jttstylek ;\\
\jttstylea ~~~~~~\jttstylek std::list\verb#<#Point\verb#>#~intPointList;\\
\jttstylea ~~~~~~\jttstylek std::list\verb#<#Point\verb#>#::iterator~it;\\
\jttstylea \\
\jttstylea ~~~~~~\jttstylek Point~p1=\verb#*#vi;\\
\jttstylea ~~~~~~\jttstylek Point~p2;\\
\jttstylea ~~~~~~\jttstylek FindCandidateIntrPoints\jttstylei (\jttstylek map,rayToCorner,intPointList\jttstylei )\jttstylek ;\\
\jttstylea \\
\jttstylea ~~~~~~\jttstylee if\jttstylei (\jttstylek intPointList.size\jttstylei ()~\jttstylek \verb#>#~\jttstyleh 0\jttstylei )\{\\
\jttstylea ~~~~~~~~\jttstyled //Sort~the~points~in~intersectionPolygon~according~to~distance\\
\jttstylea ~~~~~~~~\jttstylek intPointList.sort\jttstylei (\jttstylek CompareDistance1\jttstylei )\jttstylek ;\\
\jttstylea ~~~~~~~~\jttstylek intPointList.unique\jttstylei ()\jttstylek ;\\
\jttstylea ~~~~~~~~\jttstylek Point~spuriousVertex~=~\verb#*#intPointList.begin\jttstylei ()\jttstylek ;\\
\jttstylea ~~~~~~~~\jttstylek p2=spuriousVertex;\\
\jttstylea ~~~~~~~~\jttstylek listVisiblePoints.push\verb#_#back\jttstylei (\jttstylek spuriousVertex\jttstylei )\jttstylek ;\\
\jttstylea ~~~~~~\jttstylei \}\\
\jttstylea ~~~~\jttstylei \}\\
\jttstylea \\
\jttstylea ~~\jttstylei \}\\
\jttstylea \\
\jttstylea ~~\jttstylek listVisiblePoints=UniqueList\jttstylei (\jttstylek listVisiblePoints\jttstylei )\jttstylek ;\\
\jttstylea ~~\jttstylek list\verb#<#Point\verb#>#::iterator~it;\\
\jttstylea ~~\jttstylek Polygon~setVisiblePointsCopy;\\
\jttstylea ~~\jttstylee for\jttstylei (\jttstylek it=listVisiblePoints.begin\jttstylei ()\jttstylek ;it!=listVisiblePoints.end\jttstylei ()\jttstylek ;++it\jttstylei )\\
\jttstylea ~~\jttstylei \{\\
\jttstylea ~~~~\jttstylek setVisiblePointsCopy.push\verb#_#back\jttstylei (\jttstylek \verb#*#it\jttstylei )\jttstylek ;\\
\jttstylea ~~\jttstylei \}\\
\jttstylea \\
\jttstylea \\
\jttstylea ~~\jttstylek setVisiblePointsCopy=SortPolygon\jttstylei (\jttstylek setVisiblePointsCopy,map\jttstylei )\jttstylek ;\\
\jttstylea ~~\jttstylee return~\jttstylek setVisiblePointsCopy;\\
\jttstylei \}\\
\jttstylea \jttstylea 
\\

}




\subsection{Visibility Polygon of an edge of the polygon}
The algorithm for the visibility polygon of an edge has been taken from \cite{key3}.
Let $E$ be the set of edges of the polygon. To find the visibility polygon of an edge $AB$, we compute, for each of 
 the remaining edges of the polygon the portion of it which is weakly visible from the edge $AB$. Once we obtain these portions we join
 all of them to obtain the visibility polygon of the edge $AB$.
  Implementation of this algorithm requires computing shortest path between vertices of the polygon, the construction of which we 
describe in the next section. For now assume that we have at our disposal a routine which gives the shortest path between two vertices 
of the polygon as a list of Point type.

The main steps of computing the visible portion of an edge $CD$ from another edge $AB$ of the polygon can be enumerated as follows.

\begin{enumerate}
\item
Compute the shortest path $P_{AC}$, from A to C and the shortest path $P_{BD}$, from B to D. Call this pair 1.
\item
Similarly compute the shortest path  $P_{AD}$, from A to D and the shortest path  $P_{BC}$,  from B to C. Call this pair 2.
\item
Find out which of these pairs is outward convex. An outward convex pair implies an hourglass shape is formed by the two paths.
\item
If none of the pairs is outward convex this means that no portion of edge $CD$ is visible from any point on edge $AB$ and we can 
completely ignore such an edge.

\begin{figure}[h]
\begin{center}
\scalebox{0.50}{\includegraphics{Images/Cusp.png}}
\caption{\label{fig:Visibility Polygon of Edge}Visibility Polygon of Edge, Illustration taken from:\cite{key3}}
\end{center}
\end{figure}

\item
If one of the pairs is outward convex then without loss of generality, let pair 1 be the outward convex pair. Now compute the shortest 
paths  $P_{AD}$ and  $P_{BC}$.

\item
Let $X$ be the point where path $P_{AD}$ and $P_{AC}$ split and let  $W$ be the point where path $P_{BD}$ and $P_{BC}$ split. Let $Y$ be
the next point on the path  $P_{AD}$ and $Z$ be the next point on the path   $P_{BC}$. Extending $XY$ we get one extreme point of the 
portion of $CD$ visible from $AB$. We repeat this on other side to get the other extreme point.


\end{enumerate}

 $CalcVisibilityPolygonEdge()$ calculates the visibility polygon of an edge in PolygonUtil.cpp


\subsection{Shortest Path Calculation}
For the calculation of shortest path between any two vertices of the polygon the following property was exploited.
\begin{itemize}
 \item The shortest path must turn only at vertices of the polygon.
 \item It is possible to move from one vertex to the another only if they are visible to each other.
\end{itemize}

Utilizing these properties we construct a visibility graph for the polygon and use the normal dijikstra's single source shortest path
 algorithm on the visibility graph obtained. The following two functions do the above mentioned tasks.

\begin{itemize}

\item
%Java2TeX style definitions
%You can modify them to fit your needs

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  Java Sourcecode to TeX automatically converted code
%  Java2Html Converter 5.0 [2006-02-26]by Markus Gebhard  markus@jave.de
%     Further information: http://www.java2html.de
{
\noindent \ttfamily
\noindent \ttfamily
\noindent \ttfamily
\noindent \ttfamily
\jttstylek PolygonUtil::PrepareVisibilityGraph\jttstylei (\jttstylek Polygon\&~map,~Point~vertex\jttstylei [])\\

}


\item
%Java2TeX style definitions
%You can modify them to fit your needs

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  Java Sourcecode to TeX automatically converted code
%  Java2Html Converter 5.0 [2006-02-26]by Markus Gebhard  markus@jave.de
%     Further information: http://www.java2html.de
{
\noindent \ttfamily
\jttstylek PolygonUtil::CalcShortestPath\jttstylei (\jttstylej int~\jttstylek source,graph\verb#_#t\&~g,Point~vertex\jttstylei [])\\
\noindent \ttfamily
}

\end{itemize}


\newpage
\section{Hypothesis Generation}
Hypothesis Generation phase is based on the following conjecture which we try to prove in the next subsection.

\begin{theorem}
 A point, $P$ inside a simple polygon sees atleast one edge of the polygon completely.
\end{theorem}
The proof of the above theorem comes from the following two simple facts.
\begin{itemize}
 \item An edge is partially visible from a point inside the polygon only if it is occluded partially by another reflex vertex of the polygon
not belonging to that edge.
\item A reflex vertex can occlude one and only one edge of the polygon.
\end{itemize}

To prove the theorem for any arbitrary polygon we obtain the visibility polygon of point P and show that atleast one edge of this
visibility polygon, which is also an edge of the original polygon, is completely visible from point $P$. Alternatively Theorem 1 can be
 restated as follows.

\begin{definition}
 {\bf Spurious Edge:} In the visibility polygon of a point, an edge is called a spurious edge if it is obtained by extending the line
 joining the point $P$ and a reflex vertex till it meets the polygon.
\end{definition}


\begin{theorem}
 The visibility polygon of a point $P$ has atleast one edge which completely overlaps with an edge of the original polygon.
\end{theorem}
{\bf Proof} Let the visibility polygon be $V$ .Let the visibility polygon have $n$ non-spurious edges and $r$ spurious edges.




\newpage
\begin{thebibliography}{1}
\bibitem{key1} \emph{A Near-Tight approximation algorithm for the robot localization problem},
 Koenig, Sven and Mudgal, Proceedings of the Symposium on Discrete Algorithms SODA, 2006.

\bibitem{key2} $<$\url{http://www.cgal.org/}$>$

\bibitem{key3} \emph{Linear time algorithms for visibility and shortest path problems inside simple polygons}, Guibas, 
Hershberger, Daniel Leven, Micha Sharir, Robert E. Tarjan
\end{thebibliography}



\end{document}
